# JVM学习笔记
## 类的加载
1. 类加载及其初始化
    1. 类加载器分类为四个层级，自顶向下依次是根类加载器/启动类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）、应用类加载器/系统类加载器（AppClassLoader）、自定义类加载器（用户自定义的类加载器需要继承抽象类ClassLoader，重写findClass方法）
    2. 其中Bootstrap是内建在Java虚拟机中的，由C++写成，随虚拟机的启动生成，扩展类加载器和系统类加载器都由Bootstrap来加载，因此启动类加载器不是Java类而是**特定于平台的机器指令**，其他的类加载器都是Java类
    3. 除了java.lang.ClassLoader包下的类加载器，Bootstrap还负责加载JRE正常运行所需组件（rt.jar包中），包含java.util和java.lang包中的类等等
2. 类的加载、连接和初始化
    1. 加载：查找并加载类的二进制数据
    2. 连接：又分为验证（确保被加载的类的正确性）、准备（为类的静态变量分配内存，并将其初始化为默认值）和解析（把类中的符号引用转换为直接地址引用）三个阶段
    3. 初始化：为变量赋正确的初始值，按顺序执行静态块代码（类的主动使用导致）
    4. 使用
    5. 卸载：取决于代表类的class对象的生命周期，虚拟机自带的类加载器（三种）加载的类始终不会被卸载
3. 类加载器的双亲委托模型
    1. 确保Java核心库的类型安全：
        所有的Java应用至少都会引用java.lang.Object类，运行期该类会被加载到JVM虚拟机中，如果这个类是由Java应用自己的类加载器完成加载的话，很可能会在JVM中存在多个版本的Object类，而且这些类是互相不兼容、不可见的（命名空间发挥作用），双亲委托机制保证Java核心库之间相互兼容
    2. 确保Java核心类库所提供的类不会被自定义的类所替代
    3. 不同的类加载器可以为相同名称（binary name）的类创建额外的命名空间，相同名称的类可以并存在Java虚拟机中，只需要用不同（没有父子关系）的类加载器来加载他们即可，相当于在Java虚拟机内部创建了一个又一个相互隔离的类空间
4. SPI规范（jar hell问题）
    1. 通过线程上下文类加载器，改变双亲委托模型，实现父类加载器加载的类对子类加载器加载的类的访问
    2. JDBC JNDI JAXP
## Java字节码
1. class文件结构
    1. 顺序：魔数、版本号（先小后大）、常量池、访问控制符（与运算）、类名、父类名、接口表、变量/字段表（不包含局部变量）、方法表、属性表
    2. 向下兼容：低版本号的字节码文件可以在支持高版本号的虚拟机中执行
    3. 方法表中默认会生成`<init>`构造方法，如果类存在静态方法、静态变量或静态块则会默认生成并合并为一个`<clinit>`方法
2. jclasslib工具
3. 字节码中的异常处理（默认兜底处理，处理类型为0）
## Java内存空间
