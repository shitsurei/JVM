# JVM学习笔记
## 类的加载
1. 类加载及其初始化
    1. 类加载器分类为四个层级，自顶向下依次是根类加载器/启动类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）、应用类加载器/系统类加载器（AppClassLoader）、自定义类加载器（用户自定义的类加载器需要继承抽象类ClassLoader，重写findClass方法）
    2. 其中Bootstrap是内建在Java虚拟机中的，由C++写成，随虚拟机的启动生成，扩展类加载器和系统类加载器都由Bootstrap来加载，因此启动类加载器不是Java类而是**特定于平台的机器指令**，其他的类加载器都是Java类
    3. 除了java.lang.ClassLoader包下的类加载器，Bootstrap还负责加载JRE正常运行所需组件（rt.jar包中），包含java.util和java.lang包中的类等等
2. 类的加载、连接和初始化
    1. 加载：查找并加载类的二进制数据
    2. 连接：又分为验证（确保被加载的类的正确性）、准备（为类的静态变量分配内存，并将其初始化为默认值）和解析（把类中的符号引用转换为直接地址引用）三个阶段
    3. 初始化：为变量赋正确的初始值，按顺序执行静态块代码（类的主动使用导致）
    4. 使用
    5. 卸载：取决于代表类的class对象的生命周期，虚拟机自带的类加载器（三种）加载的类始终不会被卸载
3. 类加载器的双亲委托模型（自底向上检查类是否已经被加载，自顶向下尝试加载类）
    1. 确保Java核心库的类型安全：
        所有的Java应用至少都会引用java.lang.Object类，运行期该类会被加载到JVM虚拟机中，如果这个类是由Java应用自己的类加载器完成加载的话，很可能会在JVM中存在多个版本的Object类，而且这些类是互相不兼容、不可见的（命名空间发挥作用），双亲委托机制保证Java核心库之间相互兼容
    2. 确保Java核心类库所提供的类不会被自定义的类所替代
    3. 不同的类加载器可以为相同名称（binary name）的类创建额外的命名空间，相同名称的类可以并存在Java虚拟机中，只需要用不同（没有父子关系）的类加载器来加载他们即可，相当于在Java虚拟机内部创建了一个又一个相互隔离的类空间
    4. 真正加载某个类的类加载器称为**定义类加载器**，能够返回某个类对象引用的类加载器称为**初始类加载器**（即初始类加载器包含定义类加载器和定义类加载器的子类加载器）
    5. 加载器之间的父子关系并不是类与类之间的继承关系，而是**加载器对象之间的包装关系**，一对父子加载器可能是同一个加载器类的两个实例
4. SPI规范（jar hell问题）
    1. 通过线程上下文类加载器，改变双亲委托模型，实现父类加载器加载的类对子类加载器加载的类的访问
    2. JDBC JNDI JAXP
## Java字节码
1. class文件结构
    1. 顺序：魔数、版本号（先小后大）、常量池、访问控制符（与运算）、类名、父类名、接口表、变量/字段表（不包含局部变量）、方法表、属性表
    2. 向下兼容：低版本号的字节码文件可以在支持高版本号的虚拟机中执行
    3. 方法表中默认会生成`<init>`构造方法，如果类存在静态方法、静态变量或静态块则会默认生成并合并为一个`<clinit>`方法
2. class文件中的两种数据类型
    1. 字节数据直接量：基本数据类型，分为u1、u2、u4、u8四种，分别表示占几个字节的整体数据
    2. 表/数组：由多个基本数据或其他表按**既定顺序、既定类型**组成的大的数据集合
3. 字节码级别的异常处理
    1. jdk1.4.2之前的版本采用特殊的指令码处理异常
    2. 通过goto指令结合方法中的异常表属性来处理异常，将finally块中的字节码指令拼接在每一个catch块的指令之后
    3. 默认兜底处理，处理类型为0
4. 字节码中的多态性体现
    1. 栈帧：一种帮助虚拟机执行方法调用的数据结构，内部封装了方法的局部变量表、动态连接信息、方法返回地址以及操作数栈信息
    2. 符号引用和直接引用
    3. 静态解析（符号引用在类加载阶段或第一次使用就转换为直接引用）和动态链接（每次运行期符号引用都会转换成不一定相同的直接引用）
    4. invoke相关指令：虚方法【invokevirtual】、非虚方法【invokestatic和invokespecial】
    5. 方法的静态分派（变量的静态类型是不会发生变化的，在编译期就可以确定）和动态分派（涉及【方法接收者】、【虚方法表vtable】概念，变量的实际类型是在运行期可以发生变化的），方法重载是一种静态（编译器）行为，方法重写是一种动态（运行期）行为
5. 基于栈的指令集和基于寄存器的指令集
    1. 基于栈：主要操作是入栈出栈，可移植性强
    2. 基于寄存器：指令集数量少，CPU直接执行，执行速度快
6. 解释执行（解释器读取字节码）和编译执行（JIT，即时编译器）
## Java内存空间
1. JVM内存布局
    1. 虚拟机栈、程序计数器、本地方法栈、堆、方法区、运行时常量池、直接内存
    2. new对象创建过程：在堆内存中创建对象实例，为实例变量赋初值，返回对象引用
    3. 指针碰撞和空闲列表
2. 内存空间溢出
    1. 堆、元空间OutOfMemory错误和虚拟机栈StackOverflow错误
    2. 内存调试工具
## 垃圾回收机制
1. 垃圾回收区域
    1. 方法中创建对象时引用的局部变量存在虚拟机栈中，真正创建的对象存在堆中，方法结束后引用变量马上回收，堆中的对象需要等到下一次GC时回收
    2. 垃圾回收的主要区域在堆，其次是方法区（主要回收废弃常量和无用类）
2. GC模型
    1. 垃圾判断算法：引用计数算法（Reference Counting），根搜索算法（GC Roots Tracing）
    2. GC算法：标记清除（老），标记整理（老），复制（新）
    3. 垃圾回收器的实现和选择
    4. GC时机：Minor GC和Full GC
3. 分代算法
    1. 堆空间分为新生代，老年代和永久代（JDK8之后改为元空间）
    2. 新生代可分为Eden空间，From Survivor空间和To Survivor空间，其默认比例为8：1：1
    3. 对象一般情况下载新生代的Eden空间中创建，空间不足时会直接在老年代中创建
4. 垃圾回收器
    1. 针对新生代的实现的GC有Serial、ParNew、Parallel Scavenge，针对老年代实现的的GC有Serial Old、CMS、Parallel Old
    2. Serial收集器是串行，单线程的，新生代使用复制算法，老年代使用标记整理算法
    2. ParNew，PS，CMS收集器是并行，多线程的，新生代使用复制算法，老年代使用标记清除算法
5. CMS垃圾回收器（以获取最短的停顿时间为目标）
    1. 枚举根节点，OopMap，安全点（以“是否具有让程序长时间运行的特征”作为标准选择），安全区域，抢占式中断，主动式中断
    2. 七个步骤：初始标记（STW），并发标记（耗时长），并发预清理，可失败的并发预清理，重新标记（STW），并发清除（耗时长），并发重置线程
    3. 优点是并发低停顿，缺点是对CPU资源敏感，无法处理浮动垃圾，会产生内存空间碎片问题
